# Node.js 第6天课程笔记

## 复习

### 同步调用和异步调用

同步会阻塞当前代码的继续执行，直到结果返回之后，在会继续往后执行，
对于同步代码来说，我们需要使用 try-catch 来捕获一样

异步不会阻塞当前代码的继续执行，什么时候执行结束，会触发 我们设置好的回调函数，
对于异步代码来说，通常会把错误对象放到回调函数的第一个参数中，我们通过 判断 第一个参数
err对象是否为空来查看到底有没有发生异常

在有IO操作的地方，异步IO肯定是高效与同步IO的。

// 对于同步IO代码来说，就是我自己去做读取文件这件事儿，而且一次还只能做一件事儿
fs.readFileSync()   100ms
fs.readFileSync()   100ms  +  10ms
fs.readFileSync()   110ms + 200ms
fs.readFileSync()
fs.readFileSync()

这这里的异步IO相当于 找了 五个人去帮我干活了，其中的某个人什么时候把活儿干完了，
那就把最终的结果（包裹） 交给我自己，我自己在回调函数中处理自己的业务
fs.readFile(callback)  不会阻塞后续代码的继续执行
fs.readFile(callback)  不会阻塞
fs.readFile(callback)  不会阻塞
fs.readFile(callback)  不会阻塞
fs.readFile(callback)  不会阻塞

// 找了多个人去帮我去做读取文件的事儿了，而我自己还可以继续处理自己的事情
let var  = 'bar';

## 网络编程

我们处于互联网时代，我们可以随时随地通过 Internet 上网、浏览新闻、玩LOL、上淘宝购物等等。
这些过程都发生了网络数据的交互。树莓派

简单来说：比如你正在手机上浏览网易新闻，对汪峰上头条很感兴趣，点击该链接后，就会进入新闻，
那么就会发生一件事：发出请求给网易服务器（告诉网易服务器我要查看汪峰上头条这条新闻），
服务器解析你的请求，返回汪峰头条新闻的具体内容。这个过程发生了数据的交换，
也就是请求数据传输给了网易服务器，网易服务器又返回响应数据给客户端。

所以，网络编程 是指**编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。**
注意：这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。

强调：网络编程重在思想，node只是一个可以帮助我们学习网络编程的一个工具而已。
使用其他编程语言或者操作系统进行网络编程，思想都是一样的。

### 为什么叫 Node

Node是一个面向网络而生的平台。

Ryan Dahl 在创建Node项目的时候给它起了一个名字叫做 web.js ，就是一个Web服务器。
类似于 Apache、tomcat、IIS 等服务器软件。

web.js 的发展超出了作者的最初想法，变成了构建网络应用的一个基础平台。
然后就可以在这个基础平台之上构建很多东西，比如服务器、客户端、各种各样的命令行工具等。

Node的目标就是成为一个构建快速、可伸缩的网络应用平台。

每一个Node进程构成网络应用中的一个节点。这就是 Node 的含义。

### Node 没有 Web 容器

.net平台的 ASP或者ASP.net 需要 IIS 作为服务器容器，
PHP需要搭载 Apache 或者 Nginx 作为服务器容器，
Java 的 JSP 需要 tomcat 作为服务器容器，
ruby 的 ruby on rails 需要 搭配 Apache 等作为自己的服务器容器。。。


Node，不需要服务器容器。
Node，不需要服务器容器。
Node，不需要服务器容器。

### 网络协议

关于协议详见PPT第140页。

网络之间传输数据就需要协议。
所谓的协议就是双方约定好的一些数据格式。
否则两台计算机之间如何识别对方发送过来的 0 1 数据。
再次强调，计算机很傻，计算机本身也是人造出来的，
所以说协议本身也是由我们早期的先辈们制定和开发出来的。

在 OSI（开放系统互联(Open System Interconnection)）模型中，把网络通信的工作分为了7层，它们分别是：
- HTTP、SMTP、IMAP等 应用层
- 加密/解密等        表示层
- 通信连接/维持会话  会话层
- TCP/UDP            传输层
- IP                 网络层
- 网络特有的链路接口 链路层
- 网络物理硬件       物理层

也有人将网络通信的工作分为了5层，便于我们的理解。
- 应用层（Application Layer） HTTP、SMTP
- 传输层（Transport Layer）   负责安全可靠的把数据发送到对方的计算机
- 网络层（Network Layer）     负责ip地址、Mac地址 定位网络
- 链路层（Link Layer）        跟网络层很像，也是用来将我们发送的信号进行组网
- 实体层（Physical Layer）     双绞线、光钎、电线（电力猫）、无线电波

越下面的层，越靠近硬件；
越上面的层，越靠近用户。

每一层都是为了完成一种功能，层与层之间相互协作，才能构成计算机之间正常的网络通信。

### TCP 传输层协议

TCP 是面向连接的协议，最大的特性就是在传输之前需要3次握手形成会话。

可靠性。

打开控制台 -> 在查看方式中切换到 类别 -> 程序 -> 启用或关闭Windows功能 -> 
找到 Telnet客户端 选项，打上对勾 然后选择确定即可，这样的话就开启了 Telnet 功能，
就可以在命令台使用了

### Socket

Socket 又叫做套接字，网络编程又叫做套接字编程。
而Socket 地址又称为 套接字地址，可以理解为计算机的网络地址。

假设你想和你的女神打电话，但是必须知道对方的电话号码才可以，
而我们进行网络通信也需要知道对方的 Socket 地址。

在网络通信中，采用类似方法标识Socket地址。
Socket地址最关键的两部分为（ip，port）
就是ip地址和端口号，
比如一个网络地址为 192.168.3.6:3000
那么，192.168.3.6 就是用来定位和区分计算机的
3000端口号就是用来区分不同的套接字的

### TCP 服务的事件：

#### 服务器事件

- listening：调用 server.listen() 绑定端口之后会触发
- connection：每个客户端套接字连接到服务器时触发
- close：当服务器关闭时会触发，只有手动调用 server.close() 之后会触发该事件
- error：当服务器发生异常的时候，会触发该事件

#### 连接事件

- data 当一端调用 write() 方法发送数据时，另一端就会触发 data 事件，事件回调处理函数中的参数就是 write() 发送的数据
- end 当连接中的任意一端发送了 FIN 数据时，将会触发该事件
- connect 该事件用于客户端，当套接字与服务器连接成功时会被触发
- error：当异常发生时，触发该事件
- close：当套接字完全关闭时，触发该事件


## 双向通信

## 控制台聊天室

### 先实现一个可以让服务器回答某些特定问题的功能

当客户端输入 hello 的时候，服务器响应一个 world
当客户端输入 haha 的时候，服务器响应一个 hehe
当客户端输入 你吃了吗 的时候，服务器响应一个 我吃的小豆包
当客户点输入 别的服务器无法识别的问题的时候，响应一个 你说类啥


### 通过 nodemon 实现 保存文件实时重启

1. 安装ndemon ` npm install -g nodemon `
2. 基本使用 `nodemon server.js`

只要执行了上面的命令，那么当你修改了 server.js 那么nodemon会帮你自动重启 server

### 制定协议（服务器和客户端之间数据格式的约定）

nickname


当用户来连接我们的服务器的时候，提示用户：

请输入你的昵称按回车进入：

注册昵称
如果昵称被占用：提示用户，昵称已存在，请重新输入
如果昵称没有被占用，则用户就可以进入聊天室

广播消息
当用户进入聊天室之后，
一种方式，可以直接发送消息，默认就是广播消息
消息体

私聊
当用户想向特定的某人发送消息的时候：
nickname:要说的话

需求如上：

数据格式协议如下：
注册的数据格式
{
  protocol:'signup',
  nickname:''
}

广播的数据格式
{
  protocol: 'broadcast',
  from: '',
  message: ''
}

leijun:atr you ok
私聊
{
  protocol: 'p2p',
  from: '',
  to: '',
  message: ''
}

### 实现广播消息

### 实现用户注册

### 实现点对对消息

### 作业：把今天写的代码写两遍

自己思考一下，加一个群的功能。

要考虑数据结构和数据通信格式问题。
