# JavaScript 模块化编程
### 网站越来越复杂，js代码和文件也越来越多，会遇到什么问题？
1. 代码越来越乱了
2. 命名冲突
3. 文件依赖的问题
4. 各种问题
## 什么是模块化
1. 现实生活中模块化的例子
	1. 模块化计算机
	2. 谷歌模块化手机
	3. 模块化房屋
2. 代码模块化例子
	1. 日期模块
	2. 数组计算模块
	3. 日志模块
## 模块化开发演变
### 程序模块化开发优点
1. 开发效率高
 1. 代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发类似的功能
2. 方便后期维护
 1. 软件的声明周期中最长的阶段其实并不是开发阶段，而是维护阶段，需求变更比较频繁，使用模块化的开发方式更容易维护





代码seajs.org/docs/

### 程序模块化
1. 日期模块
2. 数组计算模块
3. 日志模块
4. 登陆认证模块
5. 报表展示模块
6. 所有这些模块共同组成了程序软件系统
### 非模块化开发带来的问题-命名冲突
### 全局函数
全局函数方式污染了全局变量。

命名冲突的问题

模块的关系不够明显
### 命名空间
命名空间的方式减少了命名冲突的问题

暴露了所有的模块成员，内部

命名空间的形式会越来越长，不容易记忆，而且代码不够优雅
### 划分私有空间
防止内部属性被外部修改了
### 对象封装
1. 理论意义上解决了命名冲突的问题(通过人为约定的方式)
2. 没有私有化空间，容易被外部修改

### 模块的维护扩展
模块的扩展一定要遵守一个约定：开闭原则

对添加开放、对修改封闭
### 模块依赖的问题


### 模块的第三方依赖
1. 不要直接在模块内部使用第三方依赖
2. 模块与模块之间的依赖关系不够明显
3. 最好通过将依赖项注入的形式来解决第三方依赖的问题依赖注入
### 总结
1. 最大的问题，规范的问题
2. 如果在多人协作开发过程中，会有很大的问题
3. 多人协作开发过程中：代码的风格一定要统一

## 模块化规范
### 服务器端模块化规范

### 浏览器端模块化规范

- AMD
    + RequireJS
- CMD
    + SeaJS

## SeaJS

### 基本使用

### 整体感知

### 定义模块 define

### 启动模块 seajs.use

### 加载模块 require

### 暴露接口 exports 和 module.exports

### 高级配置

### 异步加载模块

### 加载第三方依赖模块

### 综合练习：改造游戏案例
### 说一下 SeaJS 和 jQuery 是什么关系？
1. 它们之间没有任何的关系
2. jQuery 专注于 DOM 操作，帮我们解决一些兼容性的问题，直接干活的，直接参与我们的业务逻辑，就是一个冲锋陷阵的士兵
3. SeaJS 用来管理为组织我们的代码的
	1. 解决了命名冲突
	2. 解决了文件依赖的问题
	3. 后勤
	4. SeaJS是专注于js文件的和js代码
## 作业
通过seajs 的模块化方式，编写三个组件

- 一个是拖拽组件
- 一个是选项卡组件
- 一个弹窗组件

		JavaScript
		function Tab(config){
		    this.settings = config; 
		}
		Tab.prototype.init = function() {
		
		};
		function Drag(){
		    
		}
		function Dialog(){
		
		}




****

什么是模块化
现实中的模块化
就是一种生产的方式而已
生产效率高
维护方便，成本低
程序中的模块化
就是开发方式而已（代码的编写和组织方式）
开发效率高
方便维护了（维护的成本更低）
为什么要在程序中使用模块化的开发方式
命名冲突
文件依赖
SeaJS的使用
seajs.use方法是异步加载js模块的

async表示异步

module.exports.foo = 'bar';等价于

require实际上得到的是add.js文件中暴露的接口对象module.exports

在整个模块系统中，require加载的文件模块会被缓存，一次加载，后面就不用重新加载了

require默认就是同步加载一个模块

异步形式加载一个模块，通过在回调函数中传入一个形参用来接收该模块中暴露的module.exports对象

require 实际上得到的是 add.js 文件中暴露的接口对象 module.exports

定义模块 define
加载模块 require
在一个模块系统中，require加载过的模块会被缓存
默认 require 是同步加载模块的
可以通过 require.async('模块标识',callback)使用异步的方式加载一个模块
暴露接口 exports 和 module.exports
启动模块系统 eajs.use(callback)
seajs.use 和 Document 的 ready 没有任何关系
要想保证 文档结构加载完毕再执行你的 js 代码，一定要在 seajs.use 内部通过 window.onload 或者 $(function(){})
分清楚前台模块化和node中的模块化的区别
掌握模块化的思想